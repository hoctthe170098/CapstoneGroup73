//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IApplicationUsersClient {
    login(comand: LoginComand): Observable<Output>;
    forgotPassword(comand: ForgotPasswordComand): Observable<Output>;
    changePassword(comand: ChangePasswordComand): Observable<Output>;
}

@Injectable({
    providedIn: 'root'
})
export class ApplicationUsersClient implements IApplicationUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    login(comand: LoginComand): Observable<Output> {
        let url_ = this.baseUrl + "/api/ApplicationUsers/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    forgotPassword(comand: ForgotPasswordComand): Observable<Output> {
        let url_ = this.baseUrl + "/api/ApplicationUsers/forgotpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changePassword(comand: ChangePasswordComand): Observable<Output> {
        let url_ = this.baseUrl + "/api/ApplicationUsers/changepassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IChinhSachsClient {
    createChinhSach(command: CreateChinhSachCommand): Observable<Output>;
    updateChinhSach(command: UpdateChinhSachCommand): Observable<Output>;
    getChinhSachsWithPagination(query: GetChinhSachsWithPaginationQuery): Observable<Output>;
    getAllChinhSachs(): Observable<Output>;
    deleteChinhSach(id: string): Observable<Output>;
}

@Injectable({
    providedIn: 'root'
})
export class ChinhSachsClient implements IChinhSachsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createChinhSach(command: CreateChinhSachCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/ChinhSachs/createchinhsach";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateChinhSach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateChinhSach(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processCreateChinhSach(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateChinhSach(command: UpdateChinhSachCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/ChinhSachs/updatechinhsach";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateChinhSach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateChinhSach(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processUpdateChinhSach(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getChinhSachsWithPagination(query: GetChinhSachsWithPaginationQuery): Observable<Output> {
        let url_ = this.baseUrl + "/api/ChinhSachs/getchinhsachs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChinhSachsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChinhSachsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processGetChinhSachsWithPagination(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllChinhSachs(): Observable<Output> {
        let url_ = this.baseUrl + "/api/ChinhSachs/getallchinhsachs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChinhSachs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChinhSachs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processGetAllChinhSachs(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteChinhSach(id: string): Observable<Output> {
        let url_ = this.baseUrl + "/api/ChinhSachs/deletechinhsach/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteChinhSach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteChinhSach(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processDeleteChinhSach(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IChuongTrinhsClient {
    createChuongTrinh(command: CreateChuongTrinhCommand): Observable<Output>;
    updateChuongTrinh(command: UpdateChuongTrinhCommand): Observable<Output>;
    getChuongTrinhsWithPagination(query: GetChuongTrinhsWithPaginationQuery): Observable<Output>;
    getAllChuongTrinhs(): Observable<Output>;
    deleteChuongTrinh(id: string): Observable<Output>;
}

@Injectable({
    providedIn: 'root'
})
export class ChuongTrinhsClient implements IChuongTrinhsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createChuongTrinh(command: CreateChuongTrinhCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/ChuongTrinhs/createchuongtrinh?";
        if (command === undefined || command === null)
            throw new Error("The parameter 'command' must be defined and cannot be null.");
        else
            url_ += "command=" + encodeURIComponent("" + command) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateChuongTrinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateChuongTrinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processCreateChuongTrinh(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateChuongTrinh(command: UpdateChuongTrinhCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/ChuongTrinhs/updatechuongtrinh?";
        if (command === undefined || command === null)
            throw new Error("The parameter 'command' must be defined and cannot be null.");
        else
            url_ += "command=" + encodeURIComponent("" + command) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateChuongTrinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateChuongTrinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processUpdateChuongTrinh(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getChuongTrinhsWithPagination(query: GetChuongTrinhsWithPaginationQuery): Observable<Output> {
        let url_ = this.baseUrl + "/api/ChuongTrinhs/getchuongtrinhs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChuongTrinhsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChuongTrinhsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processGetChuongTrinhsWithPagination(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllChuongTrinhs(): Observable<Output> {
        let url_ = this.baseUrl + "/api/ChuongTrinhs/getallchuongtrinhs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChuongTrinhs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChuongTrinhs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processGetAllChuongTrinhs(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteChuongTrinh(id: string): Observable<Output> {
        let url_ = this.baseUrl + "/api/ChuongTrinhs/deletechuongtrinh/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteChuongTrinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteChuongTrinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processDeleteChuongTrinh(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICoSosClient {
    createCoSo(comand: CreateCoSoComand): Observable<Output>;
    getCoSosWithPagination(query: GetCososWithPaginationQuery): Observable<Output>;
    getAllCoSos(): Observable<Output>;
    editCoSo(comand: EditCoSoComand): Observable<Output>;
}

@Injectable({
    providedIn: 'root'
})
export class CoSosClient implements ICoSosClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createCoSo(comand: CreateCoSoComand): Observable<Output> {
        let url_ = this.baseUrl + "/api/CoSos/createcoso";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCoSo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCoSo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processCreateCoSo(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCoSosWithPagination(query: GetCososWithPaginationQuery): Observable<Output> {
        let url_ = this.baseUrl + "/api/CoSos/getcososwithpagination";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoSosWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoSosWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processGetCoSosWithPagination(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCoSos(): Observable<Output> {
        let url_ = this.baseUrl + "/api/CoSos/getallcosos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCoSos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCoSos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processGetAllCoSos(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editCoSo(comand: EditCoSoComand): Observable<Output> {
        let url_ = this.baseUrl + "/api/CoSos/editcoso";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCoSo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCoSo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processEditCoSo(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGiaoViensClient {
    createGiaoVien(comand: CreateGiaoVienCommand): Observable<Output>;
    getGiaoViensWithPagination(query: GetGiaoViensWithPaginationQuery): Observable<Output>;
    editGiaoVien(comand: EditGiaoVienCommand): Observable<Output>;
    addListGiaoViens(comand: AddListGiaoViensCommand): Observable<Output>;
}

@Injectable({
    providedIn: 'root'
})
export class GiaoViensClient implements IGiaoViensClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createGiaoVien(comand: CreateGiaoVienCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/GiaoViens/creategiaovien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGiaoVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGiaoVien(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processCreateGiaoVien(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getGiaoViensWithPagination(query: GetGiaoViensWithPaginationQuery): Observable<Output> {
        let url_ = this.baseUrl + "/api/GiaoViens/getgiaovienswithpagination";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGiaoViensWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGiaoViensWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processGetGiaoViensWithPagination(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editGiaoVien(comand: EditGiaoVienCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/GiaoViens/editgiaovien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditGiaoVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditGiaoVien(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processEditGiaoVien(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addListGiaoViens(comand: AddListGiaoViensCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/GiaoViens/addlistgiaoviens";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddListGiaoViens(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddListGiaoViens(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processAddListGiaoViens(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IHocSinhsClient {
    createHocSinh(command: CreateHocSinhCommand): Observable<Output>;
    getHocSinhsWithPagination(query: GetHocSinhsWithPaginationQuery): Observable<Output>;
    editHocSinh(command: EditHocSinhCommand): Observable<Output>;
    addListHocSinhs(command: AddListHocSinhsCommand): Observable<Output>;
}

@Injectable({
    providedIn: 'root'
})
export class HocSinhsClient implements IHocSinhsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createHocSinh(command: CreateHocSinhCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/HocSinhs/createhocsinh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHocSinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHocSinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processCreateHocSinh(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getHocSinhsWithPagination(query: GetHocSinhsWithPaginationQuery): Observable<Output> {
        let url_ = this.baseUrl + "/api/HocSinhs/gethocsinhswithpagination";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHocSinhsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHocSinhsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processGetHocSinhsWithPagination(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editHocSinh(command: EditHocSinhCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/HocSinhs/edithocsinh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditHocSinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditHocSinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processEditHocSinh(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addListHocSinhs(command: AddListHocSinhsCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/HocSinhs/addlisthocsinhs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddListHocSinhs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddListHocSinhs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processAddListHocSinhs(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILichHocsClient {
    createLichHoc(command: CreateLichHocCommand): Observable<Output>;
    editLichHoc(command: EditLichHocCommand): Observable<Output>;
}

@Injectable({
    providedIn: 'root'
})
export class LichHocsClient implements ILichHocsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createLichHoc(command: CreateLichHocCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/LichHocs/createlichhoc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLichHoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLichHoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processCreateLichHoc(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editLichHoc(command: EditLichHocCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/LichHocs/editlichhoc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditLichHoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditLichHoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processEditLichHoc(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface INhanViensClient {
    createNhanVien(comand: CreateNhanVienCommand): Observable<Output>;
    getNhanViensWithPagination(query: GetNhanViensWithPaginationQuery): Observable<Output>;
    editNhanVien(comand: EditNhanVienCommand): Observable<Output>;
}

@Injectable({
    providedIn: 'root'
})
export class NhanViensClient implements INhanViensClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createNhanVien(comand: CreateNhanVienCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/NhanViens/createnhanvien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNhanVien(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processCreateNhanVien(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNhanViensWithPagination(query: GetNhanViensWithPaginationQuery): Observable<Output> {
        let url_ = this.baseUrl + "/api/NhanViens/getnhanvienswithpagination";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNhanViensWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNhanViensWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processGetNhanViensWithPagination(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editNhanVien(comand: EditNhanVienCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/NhanViens/editnhanvien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditNhanVien(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processEditNhanVien(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPhongsClient {
    createPhong(command: CreatePhongCommand): Observable<Output>;
    getPhongsWithPagination(query: GetPhongsQuery): Observable<Output>;
    editPhong(command: EditPhongCommand): Observable<Output>;
}

@Injectable({
    providedIn: 'root'
})
export class PhongsClient implements IPhongsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createPhong(command: CreatePhongCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/Phongs/createphong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePhong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePhong(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processCreatePhong(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPhongsWithPagination(query: GetPhongsQuery): Observable<Output> {
        let url_ = this.baseUrl + "/api/Phongs/getphongswithpagination";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhongsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhongsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processGetPhongsWithPagination(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editPhong(command: EditPhongCommand): Observable<Output> {
        let url_ = this.baseUrl + "/api/Phongs/editphong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditPhong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditPhong(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Output>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Output>;
        }));
    }

    protected processEditPhong(response: HttpResponseBase): Observable<Output> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Output.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITodoItemsClient {
    getTodoItemsWithPagination(listId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfTodoItemBriefDto>;
    createTodoItem(command: CreateTodoItemCommand): Observable<number>;
    updateTodoItem(id: number, command: UpdateTodoItemCommand): Observable<void>;
    deleteTodoItem(id: number): Observable<void>;
    updateTodoItemDetail(id: number, command: UpdateTodoItemDetailCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoItemsClient implements ITodoItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getTodoItemsWithPagination(listId: number, pageNumber: number, pageSize: number): Observable<PaginatedListOfTodoItemBriefDto> {
        let url_ = this.baseUrl + "/api/TodoItems?";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined and cannot be null.");
        else
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTodoItemsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTodoItemsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTodoItemBriefDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTodoItemBriefDto>;
        }));
    }

    protected processGetTodoItemsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfTodoItemBriefDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTodoItemBriefDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTodoItem(command: CreateTodoItemCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTodoItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTodoItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTodoItem(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTodoItem(id: number, command: UpdateTodoItemCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTodoItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTodoItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTodoItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTodoItem(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTodoItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTodoItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTodoItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTodoItemDetail(id: number, command: UpdateTodoItemDetailCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTodoItemDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTodoItemDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTodoItemDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITodoListsClient {
    getTodoLists(): Observable<TodosVm>;
    createTodoList(command: CreateTodoListCommand): Observable<number>;
    updateTodoList(id: number, command: UpdateTodoListCommand): Observable<void>;
    deleteTodoList(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoListsClient implements ITodoListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getTodoLists(): Observable<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTodoLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTodoLists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TodosVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TodosVm>;
        }));
    }

    protected processGetTodoLists(response: HttpResponseBase): Observable<TodosVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTodoList(command: CreateTodoListCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTodoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTodoList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTodoList(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTodoList(id: number, command: UpdateTodoListCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTodoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTodoList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTodoList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTodoList(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTodoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTodoList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTodoList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherForecastsClient {
    getWeatherForecasts(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastsClient implements IWeatherForecastsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getWeatherForecasts(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecasts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeatherForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeatherForecasts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGetWeatherForecasts(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Output implements IOutput {
    isError?: boolean | undefined;
    code?: number;
    data?: any | undefined;
    message?: string | undefined;
    errors?: any[] | undefined;

    constructor(data?: IOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.code = _data["code"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): Output {
        data = typeof data === 'object' ? data : {};
        let result = new Output();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["code"] = this.code;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IOutput {
    isError?: boolean | undefined;
    code?: number;
    data?: any | undefined;
    message?: string | undefined;
    errors?: any[] | undefined;
}

export class LoginComand implements ILoginComand {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginComand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginComand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginComand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginComand {
    userName?: string | undefined;
    password?: string | undefined;
}

export class ForgotPasswordComand implements IForgotPasswordComand {
    email?: string | undefined;
    soDienThoai?: string | undefined;

    constructor(data?: IForgotPasswordComand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
        }
    }

    static fromJS(data: any): ForgotPasswordComand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordComand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        return data;
    }
}

export interface IForgotPasswordComand {
    email?: string | undefined;
    soDienThoai?: string | undefined;
}

export class ChangePasswordComand implements IChangePasswordComand {
    token?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordComand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordComand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordComand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordComand {
    token?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class CreateChinhSachCommand implements ICreateChinhSachCommand {
    createChinhSachDto?: CreateChinhSachDto;

    constructor(data?: ICreateChinhSachCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createChinhSachDto = _data["createChinhSachDto"] ? CreateChinhSachDto.fromJS(_data["createChinhSachDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateChinhSachCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChinhSachCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createChinhSachDto"] = this.createChinhSachDto ? this.createChinhSachDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateChinhSachCommand {
    createChinhSachDto?: CreateChinhSachDto;
}

export class CreateChinhSachDto implements ICreateChinhSachDto {
    ten?: string;
    mota?: string;
    phanTramGiam?: number;

    constructor(data?: ICreateChinhSachDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.mota = _data["mota"];
            this.phanTramGiam = _data["phanTramGiam"];
        }
    }

    static fromJS(data: any): CreateChinhSachDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChinhSachDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["mota"] = this.mota;
        data["phanTramGiam"] = this.phanTramGiam;
        return data;
    }
}

export interface ICreateChinhSachDto {
    ten?: string;
    mota?: string;
    phanTramGiam?: number;
}

export class UpdateChinhSachCommand implements IUpdateChinhSachCommand {
    updateChinhSachDto?: UpdateChinhSachDto;

    constructor(data?: IUpdateChinhSachCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.updateChinhSachDto = _data["updateChinhSachDto"] ? UpdateChinhSachDto.fromJS(_data["updateChinhSachDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateChinhSachCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateChinhSachCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updateChinhSachDto"] = this.updateChinhSachDto ? this.updateChinhSachDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateChinhSachCommand {
    updateChinhSachDto?: UpdateChinhSachDto;
}

export class UpdateChinhSachDto implements IUpdateChinhSachDto {
    id?: number;
    ten?: string | undefined;
    mota?: string | undefined;
    phanTramGiam?: number | undefined;

    constructor(data?: IUpdateChinhSachDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ten = _data["ten"];
            this.mota = _data["mota"];
            this.phanTramGiam = _data["phanTramGiam"];
        }
    }

    static fromJS(data: any): UpdateChinhSachDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateChinhSachDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ten"] = this.ten;
        data["mota"] = this.mota;
        data["phanTramGiam"] = this.phanTramGiam;
        return data;
    }
}

export interface IUpdateChinhSachDto {
    id?: number;
    ten?: string | undefined;
    mota?: string | undefined;
    phanTramGiam?: number | undefined;
}

export class GetChinhSachsWithPaginationQuery implements IGetChinhSachsWithPaginationQuery {
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IGetChinhSachsWithPaginationQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): GetChinhSachsWithPaginationQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetChinhSachsWithPaginationQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IGetChinhSachsWithPaginationQuery {
    pageNumber?: number;
    pageSize?: number;
}

export class CreateChuongTrinhCommand implements ICreateChuongTrinhCommand {
    chuongTrinhDto?: CreateChuongTrinhDto;

    constructor(data?: ICreateChuongTrinhCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chuongTrinhDto = _data["chuongTrinhDto"] ? CreateChuongTrinhDto.fromJS(_data["chuongTrinhDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateChuongTrinhCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChuongTrinhCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chuongTrinhDto"] = this.chuongTrinhDto ? this.chuongTrinhDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateChuongTrinhCommand {
    chuongTrinhDto?: CreateChuongTrinhDto;
}

export class CreateChuongTrinhDto implements ICreateChuongTrinhDto {
    tieuDe?: string;
    moTa?: string;
    noiDungBaiHocs?: CreateNoiDungBaiHocDto[] | undefined;

    constructor(data?: ICreateChuongTrinhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tieuDe = _data["tieuDe"];
            this.moTa = _data["moTa"];
            if (Array.isArray(_data["noiDungBaiHocs"])) {
                this.noiDungBaiHocs = [] as any;
                for (let item of _data["noiDungBaiHocs"])
                    this.noiDungBaiHocs!.push(CreateNoiDungBaiHocDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateChuongTrinhDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChuongTrinhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tieuDe"] = this.tieuDe;
        data["moTa"] = this.moTa;
        if (Array.isArray(this.noiDungBaiHocs)) {
            data["noiDungBaiHocs"] = [];
            for (let item of this.noiDungBaiHocs)
                data["noiDungBaiHocs"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateChuongTrinhDto {
    tieuDe?: string;
    moTa?: string;
    noiDungBaiHocs?: CreateNoiDungBaiHocDto[] | undefined;
}

export class CreateNoiDungBaiHocDto implements ICreateNoiDungBaiHocDto {
    tieuDe?: string;
    mota?: string;
    soThuTu?: number;
    taiLieuHocTaps?: CreateTaiLieuHocTapDto[] | undefined;

    constructor(data?: ICreateNoiDungBaiHocDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tieuDe = _data["tieuDe"];
            this.mota = _data["mota"];
            this.soThuTu = _data["soThuTu"];
            if (Array.isArray(_data["taiLieuHocTaps"])) {
                this.taiLieuHocTaps = [] as any;
                for (let item of _data["taiLieuHocTaps"])
                    this.taiLieuHocTaps!.push(CreateTaiLieuHocTapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateNoiDungBaiHocDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNoiDungBaiHocDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tieuDe"] = this.tieuDe;
        data["mota"] = this.mota;
        data["soThuTu"] = this.soThuTu;
        if (Array.isArray(this.taiLieuHocTaps)) {
            data["taiLieuHocTaps"] = [];
            for (let item of this.taiLieuHocTaps)
                data["taiLieuHocTaps"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateNoiDungBaiHocDto {
    tieuDe?: string;
    mota?: string;
    soThuTu?: number;
    taiLieuHocTaps?: CreateTaiLieuHocTapDto[] | undefined;
}

export class CreateTaiLieuHocTapDto implements ICreateTaiLieuHocTapDto {
    urlType?: string;
    file?: string | undefined;

    constructor(data?: ICreateTaiLieuHocTapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.urlType = _data["urlType"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): CreateTaiLieuHocTapDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTaiLieuHocTapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["urlType"] = this.urlType;
        data["file"] = this.file;
        return data;
    }
}

export interface ICreateTaiLieuHocTapDto {
    urlType?: string;
    file?: string | undefined;
}

export class UpdateChuongTrinhCommand implements IUpdateChuongTrinhCommand {
    chuongTrinhDto?: UpdateChuongTrinhDto;

    constructor(data?: IUpdateChuongTrinhCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chuongTrinhDto = _data["chuongTrinhDto"] ? UpdateChuongTrinhDto.fromJS(_data["chuongTrinhDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateChuongTrinhCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateChuongTrinhCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chuongTrinhDto"] = this.chuongTrinhDto ? this.chuongTrinhDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateChuongTrinhCommand {
    chuongTrinhDto?: UpdateChuongTrinhDto;
}

export class UpdateChuongTrinhDto implements IUpdateChuongTrinhDto {
    id?: number;
    tieuDe?: string;
    moTa?: string;
    trangThai?: string;
    noiDungBaiHocs?: UpdateNoiDungBaiHocDto[] | undefined;

    constructor(data?: IUpdateChuongTrinhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tieuDe = _data["tieuDe"];
            this.moTa = _data["moTa"];
            this.trangThai = _data["trangThai"];
            if (Array.isArray(_data["noiDungBaiHocs"])) {
                this.noiDungBaiHocs = [] as any;
                for (let item of _data["noiDungBaiHocs"])
                    this.noiDungBaiHocs!.push(UpdateNoiDungBaiHocDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateChuongTrinhDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateChuongTrinhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tieuDe"] = this.tieuDe;
        data["moTa"] = this.moTa;
        data["trangThai"] = this.trangThai;
        if (Array.isArray(this.noiDungBaiHocs)) {
            data["noiDungBaiHocs"] = [];
            for (let item of this.noiDungBaiHocs)
                data["noiDungBaiHocs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateChuongTrinhDto {
    id?: number;
    tieuDe?: string;
    moTa?: string;
    trangThai?: string;
    noiDungBaiHocs?: UpdateNoiDungBaiHocDto[] | undefined;
}

export class UpdateNoiDungBaiHocDto implements IUpdateNoiDungBaiHocDto {
    id?: string | undefined;
    tieuDe?: string;
    mota?: string;
    soThuTu?: number;
    taiLieuHocTaps?: UpdateTaiLieuHocTapDto[] | undefined;

    constructor(data?: IUpdateNoiDungBaiHocDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tieuDe = _data["tieuDe"];
            this.mota = _data["mota"];
            this.soThuTu = _data["soThuTu"];
            if (Array.isArray(_data["taiLieuHocTaps"])) {
                this.taiLieuHocTaps = [] as any;
                for (let item of _data["taiLieuHocTaps"])
                    this.taiLieuHocTaps!.push(UpdateTaiLieuHocTapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNoiDungBaiHocDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNoiDungBaiHocDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tieuDe"] = this.tieuDe;
        data["mota"] = this.mota;
        data["soThuTu"] = this.soThuTu;
        if (Array.isArray(this.taiLieuHocTaps)) {
            data["taiLieuHocTaps"] = [];
            for (let item of this.taiLieuHocTaps)
                data["taiLieuHocTaps"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateNoiDungBaiHocDto {
    id?: string | undefined;
    tieuDe?: string;
    mota?: string;
    soThuTu?: number;
    taiLieuHocTaps?: UpdateTaiLieuHocTapDto[] | undefined;
}

export class UpdateTaiLieuHocTapDto implements IUpdateTaiLieuHocTapDto {
    id?: string | undefined;
    urlType?: string;
    file?: string | undefined;

    constructor(data?: IUpdateTaiLieuHocTapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.urlType = _data["urlType"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): UpdateTaiLieuHocTapDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaiLieuHocTapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["urlType"] = this.urlType;
        data["file"] = this.file;
        return data;
    }
}

export interface IUpdateTaiLieuHocTapDto {
    id?: string | undefined;
    urlType?: string;
    file?: string | undefined;
}

export class GetChuongTrinhsWithPaginationQuery implements IGetChuongTrinhsWithPaginationQuery {
    search?: string | undefined;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IGetChuongTrinhsWithPaginationQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.search = _data["search"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): GetChuongTrinhsWithPaginationQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetChuongTrinhsWithPaginationQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["search"] = this.search;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IGetChuongTrinhsWithPaginationQuery {
    search?: string | undefined;
    pageNumber?: number;
    pageSize?: number;
}

export class CreateCoSoComand implements ICreateCoSoComand {
    ten?: string | undefined;
    diaChi?: string | undefined;
    soDienThoai?: string | undefined;

    constructor(data?: ICreateCoSoComand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.diaChi = _data["diaChi"];
            this.soDienThoai = _data["soDienThoai"];
        }
    }

    static fromJS(data: any): CreateCoSoComand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCoSoComand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["diaChi"] = this.diaChi;
        data["soDienThoai"] = this.soDienThoai;
        return data;
    }
}

export interface ICreateCoSoComand {
    ten?: string | undefined;
    diaChi?: string | undefined;
    soDienThoai?: string | undefined;
}

export class GetCososWithPaginationQuery implements IGetCososWithPaginationQuery {
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IGetCososWithPaginationQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): GetCososWithPaginationQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCososWithPaginationQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IGetCososWithPaginationQuery {
    pageNumber?: number;
    pageSize?: number;
}

export class EditCoSoComand implements IEditCoSoComand {
    id?: string | undefined;
    ten?: string | undefined;
    diaChi?: string | undefined;
    soDienThoai?: string | undefined;
    trangThai?: string | undefined;

    constructor(data?: IEditCoSoComand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ten = _data["ten"];
            this.diaChi = _data["diaChi"];
            this.soDienThoai = _data["soDienThoai"];
            this.trangThai = _data["trangThai"];
        }
    }

    static fromJS(data: any): EditCoSoComand {
        data = typeof data === 'object' ? data : {};
        let result = new EditCoSoComand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ten"] = this.ten;
        data["diaChi"] = this.diaChi;
        data["soDienThoai"] = this.soDienThoai;
        data["trangThai"] = this.trangThai;
        return data;
    }
}

export interface IEditCoSoComand {
    id?: string | undefined;
    ten?: string | undefined;
    diaChi?: string | undefined;
    soDienThoai?: string | undefined;
    trangThai?: string | undefined;
}

export class CreateGiaoVienCommand implements ICreateGiaoVienCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    truongDangDay?: string;
    ngaySinh?: string;
    email?: string;
    soDienThoai?: string;

    constructor(data?: ICreateGiaoVienCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.ten = _data["ten"];
            this.gioiTinh = _data["gioiTinh"];
            this.diaChi = _data["diaChi"];
            this.truongDangDay = _data["truongDangDay"];
            this.ngaySinh = _data["ngaySinh"];
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
        }
    }

    static fromJS(data: any): CreateGiaoVienCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGiaoVienCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ten"] = this.ten;
        data["gioiTinh"] = this.gioiTinh;
        data["diaChi"] = this.diaChi;
        data["truongDangDay"] = this.truongDangDay;
        data["ngaySinh"] = this.ngaySinh;
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        return data;
    }
}

export interface ICreateGiaoVienCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    truongDangDay?: string;
    ngaySinh?: string;
    email?: string;
    soDienThoai?: string;
}

export class GetGiaoViensWithPaginationQuery implements IGetGiaoViensWithPaginationQuery {
    pageNumber?: number;
    pageSize?: number;
    searchTen?: string | undefined;
    sortBy?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetGiaoViensWithPaginationQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.searchTen = _data["searchTen"];
            this.sortBy = _data["sortBy"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetGiaoViensWithPaginationQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetGiaoViensWithPaginationQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["searchTen"] = this.searchTen;
        data["sortBy"] = this.sortBy;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetGiaoViensWithPaginationQuery {
    pageNumber?: number;
    pageSize?: number;
    searchTen?: string | undefined;
    sortBy?: string | undefined;
    isActive?: boolean | undefined;
}

export class EditGiaoVienCommand implements IEditGiaoVienCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    truongDangDay?: string;
    ngaySinh?: string;
    email?: string;
    soDienThoai?: string;
    status?: string;

    constructor(data?: IEditGiaoVienCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.ten = _data["ten"];
            this.gioiTinh = _data["gioiTinh"];
            this.diaChi = _data["diaChi"];
            this.truongDangDay = _data["truongDangDay"];
            this.ngaySinh = _data["ngaySinh"];
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): EditGiaoVienCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditGiaoVienCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ten"] = this.ten;
        data["gioiTinh"] = this.gioiTinh;
        data["diaChi"] = this.diaChi;
        data["truongDangDay"] = this.truongDangDay;
        data["ngaySinh"] = this.ngaySinh;
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        data["status"] = this.status;
        return data;
    }
}

export interface IEditGiaoVienCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    truongDangDay?: string;
    ngaySinh?: string;
    email?: string;
    soDienThoai?: string;
    status?: string;
}

export class AddListGiaoViensCommand implements IAddListGiaoViensCommand {
    giaoViens?: CreateGiaoVienCommand[];

    constructor(data?: IAddListGiaoViensCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["giaoViens"])) {
                this.giaoViens = [] as any;
                for (let item of _data["giaoViens"])
                    this.giaoViens!.push(CreateGiaoVienCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddListGiaoViensCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddListGiaoViensCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.giaoViens)) {
            data["giaoViens"] = [];
            for (let item of this.giaoViens)
                data["giaoViens"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAddListGiaoViensCommand {
    giaoViens?: CreateGiaoVienCommand[];
}

export class CreateHocSinhCommand implements ICreateHocSinhCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    lop?: string;
    truongDangHoc?: string;
    ngaySinh?: Date;
    email?: string;
    soDienThoai?: string;
    chinhSachId?: number | undefined;
    coSoId?: string;

    constructor(data?: ICreateHocSinhCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.ten = _data["ten"];
            this.gioiTinh = _data["gioiTinh"];
            this.diaChi = _data["diaChi"];
            this.lop = _data["lop"];
            this.truongDangHoc = _data["truongDangHoc"];
            this.ngaySinh = _data["ngaySinh"] ? new Date(_data["ngaySinh"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
            this.chinhSachId = _data["chinhSachId"];
            this.coSoId = _data["coSoId"];
        }
    }

    static fromJS(data: any): CreateHocSinhCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHocSinhCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ten"] = this.ten;
        data["gioiTinh"] = this.gioiTinh;
        data["diaChi"] = this.diaChi;
        data["lop"] = this.lop;
        data["truongDangHoc"] = this.truongDangHoc;
        data["ngaySinh"] = this.ngaySinh ? formatDate(this.ngaySinh) : <any>undefined;
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        data["chinhSachId"] = this.chinhSachId;
        data["coSoId"] = this.coSoId;
        return data;
    }
}

export interface ICreateHocSinhCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    lop?: string;
    truongDangHoc?: string;
    ngaySinh?: Date;
    email?: string;
    soDienThoai?: string;
    chinhSachId?: number | undefined;
    coSoId?: string;
}

export class GetHocSinhsWithPaginationQuery implements IGetHocSinhsWithPaginationQuery {
    pageNumber?: number;
    pageSize?: number;
    searchTen?: string | undefined;
    sortBy?: string | undefined;
    filterIsActive?: boolean | undefined;
    filterByClass?: string | undefined;

    constructor(data?: IGetHocSinhsWithPaginationQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.searchTen = _data["searchTen"];
            this.sortBy = _data["sortBy"];
            this.filterIsActive = _data["filterIsActive"];
            this.filterByClass = _data["filterByClass"];
        }
    }

    static fromJS(data: any): GetHocSinhsWithPaginationQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetHocSinhsWithPaginationQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["searchTen"] = this.searchTen;
        data["sortBy"] = this.sortBy;
        data["filterIsActive"] = this.filterIsActive;
        data["filterByClass"] = this.filterByClass;
        return data;
    }
}

export interface IGetHocSinhsWithPaginationQuery {
    pageNumber?: number;
    pageSize?: number;
    searchTen?: string | undefined;
    sortBy?: string | undefined;
    filterIsActive?: boolean | undefined;
    filterByClass?: string | undefined;
}

export class EditHocSinhCommand implements IEditHocSinhCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    lop?: string;
    truongDangHoc?: string;
    ngaySinh?: Date;
    email?: string;
    soDienThoai?: string;
    chinhSachId?: number | undefined;
    coSoId?: string;

    constructor(data?: IEditHocSinhCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.ten = _data["ten"];
            this.gioiTinh = _data["gioiTinh"];
            this.diaChi = _data["diaChi"];
            this.lop = _data["lop"];
            this.truongDangHoc = _data["truongDangHoc"];
            this.ngaySinh = _data["ngaySinh"] ? new Date(_data["ngaySinh"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
            this.chinhSachId = _data["chinhSachId"];
            this.coSoId = _data["coSoId"];
        }
    }

    static fromJS(data: any): EditHocSinhCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditHocSinhCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ten"] = this.ten;
        data["gioiTinh"] = this.gioiTinh;
        data["diaChi"] = this.diaChi;
        data["lop"] = this.lop;
        data["truongDangHoc"] = this.truongDangHoc;
        data["ngaySinh"] = this.ngaySinh ? formatDate(this.ngaySinh) : <any>undefined;
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        data["chinhSachId"] = this.chinhSachId;
        data["coSoId"] = this.coSoId;
        return data;
    }
}

export interface IEditHocSinhCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    lop?: string;
    truongDangHoc?: string;
    ngaySinh?: Date;
    email?: string;
    soDienThoai?: string;
    chinhSachId?: number | undefined;
    coSoId?: string;
}

export class AddListHocSinhsCommand implements IAddListHocSinhsCommand {
    hocSinhs?: CreateHocSinhCommand[];

    constructor(data?: IAddListHocSinhsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["hocSinhs"])) {
                this.hocSinhs = [] as any;
                for (let item of _data["hocSinhs"])
                    this.hocSinhs!.push(CreateHocSinhCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddListHocSinhsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddListHocSinhsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hocSinhs)) {
            data["hocSinhs"] = [];
            for (let item of this.hocSinhs)
                data["hocSinhs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAddListHocSinhsCommand {
    hocSinhs?: CreateHocSinhCommand[];
}

export class CreateLichHocCommand implements ICreateLichHocCommand {
    lichHocDto?: CreateLichHocDto;

    constructor(data?: ICreateLichHocCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lichHocDto = _data["lichHocDto"] ? CreateLichHocDto.fromJS(_data["lichHocDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateLichHocCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLichHocCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichHocDto"] = this.lichHocDto ? this.lichHocDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateLichHocCommand {
    lichHocDto?: CreateLichHocDto;
}

export class CreateLichHocDto implements ICreateLichHocDto {
    thu?: number;
    phongId?: number;
    tenLop?: string;
    gioBatDau?: string;
    gioKetThuc?: string;
    ngayBatDau?: string;
    ngayKetThuc?: string;
    hocPhi?: number;
    trangThai?: string;
    giaoVienCode?: string;
    chuongTrinhId?: number;

    constructor(data?: ICreateLichHocDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thu = _data["thu"];
            this.phongId = _data["phongId"];
            this.tenLop = _data["tenLop"];
            this.gioBatDau = _data["gioBatDau"];
            this.gioKetThuc = _data["gioKetThuc"];
            this.ngayBatDau = _data["ngayBatDau"];
            this.ngayKetThuc = _data["ngayKetThuc"];
            this.hocPhi = _data["hocPhi"];
            this.trangThai = _data["trangThai"];
            this.giaoVienCode = _data["giaoVienCode"];
            this.chuongTrinhId = _data["chuongTrinhId"];
        }
    }

    static fromJS(data: any): CreateLichHocDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLichHocDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thu"] = this.thu;
        data["phongId"] = this.phongId;
        data["tenLop"] = this.tenLop;
        data["gioBatDau"] = this.gioBatDau;
        data["gioKetThuc"] = this.gioKetThuc;
        data["ngayBatDau"] = this.ngayBatDau;
        data["ngayKetThuc"] = this.ngayKetThuc;
        data["hocPhi"] = this.hocPhi;
        data["trangThai"] = this.trangThai;
        data["giaoVienCode"] = this.giaoVienCode;
        data["chuongTrinhId"] = this.chuongTrinhId;
        return data;
    }
}

export interface ICreateLichHocDto {
    thu?: number;
    phongId?: number;
    tenLop?: string;
    gioBatDau?: string;
    gioKetThuc?: string;
    ngayBatDau?: string;
    ngayKetThuc?: string;
    hocPhi?: number;
    trangThai?: string;
    giaoVienCode?: string;
    chuongTrinhId?: number;
}

export class EditLichHocCommand implements IEditLichHocCommand {
    lichHocDto?: EditlLichHocDto;

    constructor(data?: IEditLichHocCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lichHocDto = _data["lichHocDto"] ? EditlLichHocDto.fromJS(_data["lichHocDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditLichHocCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditLichHocCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichHocDto"] = this.lichHocDto ? this.lichHocDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEditLichHocCommand {
    lichHocDto?: EditlLichHocDto;
}

export class EditlLichHocDto implements IEditlLichHocDto {
    id?: string;
    thu?: number | undefined;
    phongId?: number | undefined;
    tenLop?: string | undefined;
    gioBatDau?: string | undefined;
    gioKetThuc?: string | undefined;
    ngayBatDau?: string | undefined;
    ngayKetThuc?: string | undefined;
    hocPhi?: number | undefined;
    trangThai?: string | undefined;
    giaoVienCode?: string | undefined;
    chuongTrinhId?: number | undefined;

    constructor(data?: IEditlLichHocDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.thu = _data["thu"];
            this.phongId = _data["phongId"];
            this.tenLop = _data["tenLop"];
            this.gioBatDau = _data["gioBatDau"];
            this.gioKetThuc = _data["gioKetThuc"];
            this.ngayBatDau = _data["ngayBatDau"];
            this.ngayKetThuc = _data["ngayKetThuc"];
            this.hocPhi = _data["hocPhi"];
            this.trangThai = _data["trangThai"];
            this.giaoVienCode = _data["giaoVienCode"];
            this.chuongTrinhId = _data["chuongTrinhId"];
        }
    }

    static fromJS(data: any): EditlLichHocDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditlLichHocDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["thu"] = this.thu;
        data["phongId"] = this.phongId;
        data["tenLop"] = this.tenLop;
        data["gioBatDau"] = this.gioBatDau;
        data["gioKetThuc"] = this.gioKetThuc;
        data["ngayBatDau"] = this.ngayBatDau;
        data["ngayKetThuc"] = this.ngayKetThuc;
        data["hocPhi"] = this.hocPhi;
        data["trangThai"] = this.trangThai;
        data["giaoVienCode"] = this.giaoVienCode;
        data["chuongTrinhId"] = this.chuongTrinhId;
        return data;
    }
}

export interface IEditlLichHocDto {
    id?: string;
    thu?: number | undefined;
    phongId?: number | undefined;
    tenLop?: string | undefined;
    gioBatDau?: string | undefined;
    gioKetThuc?: string | undefined;
    ngayBatDau?: string | undefined;
    ngayKetThuc?: string | undefined;
    hocPhi?: number | undefined;
    trangThai?: string | undefined;
    giaoVienCode?: string | undefined;
    chuongTrinhId?: number | undefined;
}

export class CreateNhanVienCommand implements ICreateNhanVienCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    ngaySinh?: string;
    email?: string;
    soDienThoai?: string;
    coSoId?: string;
    role?: string;

    constructor(data?: ICreateNhanVienCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.ten = _data["ten"];
            this.gioiTinh = _data["gioiTinh"];
            this.diaChi = _data["diaChi"];
            this.ngaySinh = _data["ngaySinh"];
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
            this.coSoId = _data["coSoId"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): CreateNhanVienCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNhanVienCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ten"] = this.ten;
        data["gioiTinh"] = this.gioiTinh;
        data["diaChi"] = this.diaChi;
        data["ngaySinh"] = this.ngaySinh;
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        data["coSoId"] = this.coSoId;
        data["role"] = this.role;
        return data;
    }
}

export interface ICreateNhanVienCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    ngaySinh?: string;
    email?: string;
    soDienThoai?: string;
    coSoId?: string;
    role?: string;
}

export class GetNhanViensWithPaginationQuery implements IGetNhanViensWithPaginationQuery {
    pageNumber?: number;
    pageSize?: number;
    searchTen?: string | undefined;
    filterTenCoSo?: string | undefined;
    filterTenVaiTro?: string | undefined;
    sortBy?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetNhanViensWithPaginationQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.searchTen = _data["searchTen"];
            this.filterTenCoSo = _data["filterTenCoSo"];
            this.filterTenVaiTro = _data["filterTenVaiTro"];
            this.sortBy = _data["sortBy"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetNhanViensWithPaginationQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetNhanViensWithPaginationQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["searchTen"] = this.searchTen;
        data["filterTenCoSo"] = this.filterTenCoSo;
        data["filterTenVaiTro"] = this.filterTenVaiTro;
        data["sortBy"] = this.sortBy;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetNhanViensWithPaginationQuery {
    pageNumber?: number;
    pageSize?: number;
    searchTen?: string | undefined;
    filterTenCoSo?: string | undefined;
    filterTenVaiTro?: string | undefined;
    sortBy?: string | undefined;
    isActive?: boolean | undefined;
}

export class EditNhanVienCommand implements IEditNhanVienCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    ngaySinh?: string;
    email?: string;
    soDienThoai?: string;
    coSoId?: string;
    role?: string;
    status?: string;

    constructor(data?: IEditNhanVienCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.ten = _data["ten"];
            this.gioiTinh = _data["gioiTinh"];
            this.diaChi = _data["diaChi"];
            this.ngaySinh = _data["ngaySinh"];
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
            this.coSoId = _data["coSoId"];
            this.role = _data["role"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): EditNhanVienCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditNhanVienCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ten"] = this.ten;
        data["gioiTinh"] = this.gioiTinh;
        data["diaChi"] = this.diaChi;
        data["ngaySinh"] = this.ngaySinh;
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        data["coSoId"] = this.coSoId;
        data["role"] = this.role;
        data["status"] = this.status;
        return data;
    }
}

export interface IEditNhanVienCommand {
    code?: string;
    ten?: string;
    gioiTinh?: string;
    diaChi?: string;
    ngaySinh?: string;
    email?: string;
    soDienThoai?: string;
    coSoId?: string;
    role?: string;
    status?: string;
}

export class CreatePhongCommand implements ICreatePhongCommand {
    ten?: string;

    constructor(data?: ICreatePhongCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
        }
    }

    static fromJS(data: any): CreatePhongCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePhongCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        return data;
    }
}

export interface ICreatePhongCommand {
    ten?: string;
}

export class GetPhongsQuery implements IGetPhongsQuery {

    constructor(data?: IGetPhongsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetPhongsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPhongsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetPhongsQuery {
}

export class EditPhongCommand implements IEditPhongCommand {
    id?: number;
    ten?: string;
    trangThai?: string;

    constructor(data?: IEditPhongCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ten = _data["ten"];
            this.trangThai = _data["trangThai"];
        }
    }

    static fromJS(data: any): EditPhongCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditPhongCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ten"] = this.ten;
        data["trangThai"] = this.trangThai;
        return data;
    }
}

export interface IEditPhongCommand {
    id?: number;
    ten?: string;
    trangThai?: string;
}

export class PaginatedListOfTodoItemBriefDto implements IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemBriefDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TodoItemBriefDto implements ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: ITodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): TodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: LookupDto[];
    lists?: TodoListDto[];

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(LookupDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodosVm {
    priorityLevels?: LookupDto[];
    lists?: TodoListDto[];
}

export class LookupDto implements ILookupDto {
    id?: number;
    title?: string | undefined;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface ILookupDto {
    id?: number;
    title?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.colour = _data["colour"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["colour"] = this.colour;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}